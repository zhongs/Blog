---
title: 从单行滚动开始
date: 2017-10-29 15:06:21
tags: 滚动
---
<img align="center" src="http://7xqrwh.com1.z0.glb.clouddn.com/image/scrollDemo/metal-text.jpg" width="80%" height="50%">
这种效果在网页中很常见，实际开发中也经常碰到这样的需求，自己也尝试写了一个这样的效果，下面是我的一个实现方案；
<!-- more -->
![demo效果](http://7xqrwh.com1.z0.glb.clouddn.com/image/scrollDemo/ezgif-4-1fa54824c2.gif)

## 分析过程

### 初始状态
![初始状态](http://7xqrwh.com1.z0.glb.clouddn.com/image/scrollDemo/jc1.png)
* 假设只有一条滚动数据的时候。最开始，我将这条数据定位到最右边，并且设置它的transform:translate3d(100%,0,0); 这是每条数据的初始状态；

### 运动状态
![下一条数据运动时机](http://7xqrwh.com1.z0.glb.clouddn.com/image/scrollDemo/jc2.png)
* 通过改变translateX的值，让这条数据移动起来；可以观察到当translate3d(0px,0px,0px)的时候，刚好整条数据移动到屏幕上来，也正好是下一条数据的运动时机；

### 结束状态
![移除数据](http://7xqrwh.com1.z0.glb.clouddn.com/image/scrollDemo/jc4.png)
* 这条数据移动到屏幕外边，当translateX值等于屏幕宽度+自身宽度的时候，是移除数据的时机；

### 实现过程
* 最开始从接口拿到数据，放在一个ajaxArr数组里面
* ajaxArr.shift() 一条数据放入到，另外一个moveArr数组
* moveArr数组里面的数据，通过window.requestAnimationFrame来改变translate3d的值，使这条数据运动起来；
* 当处于“运动状态”中的数据，满足下一条数据运动时机时，我在把ajaxArr.shift()一条数据放入到，moveArr中；
* 当moveArr中的数据，处于“结束状态”时，把当前这条数据shift()掉；
* 当moveArr的length长度为0时，没有运动的数据，需要停掉定时器

````javascript
;
(function() {

    //监控页面性能
    var stats = new Stats();
    stats.showPanel(0);
    document.body.appendChild(stats.dom);


    var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
            window.setTimeout(callback, 1000 / 60);
        };

    var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || function(timer) {
        window.clearTimeout(timer);
    };

    var winW = $(window).width();

    //https://github.com/seajs/seajs/blob/master/dist/runtime-debug.js
    function isType(type) {
        return function(obj) {
            return {}.toString.call(obj) == "[object " + type + "]"
        }
    }

    var isObject = isType("Object")
    var isString = isType("String")
    var isArray = Array.isArray || isType("Array")
    var isFunction = isType("Function")
    var isUndefined = isType("Undefined")

    var scroll = {
        initIsOne: false, //接口数据断开，重新链接；
        moveTimer: null, //定时器
        ajaxArr: [], //接口获取来的数据
        moveArr: [], //要滚动的数据
        run: function() {
            if (this.moveTimer) {
                return;
            }
            this.moveTimer = requestAnimationFrame(this.move.bind(this));
        },
        stop: function() {
            if (this.moveTimer) {
                cancelAnimationFrame(this.moveTimer);
                this.moveTimer = null;
            }
        },

        setData: function(obj) {
            if (isObject(obj)) {
                obj.id = Math.random().toString(36).substr(3);
                this.ajaxArr.unshift(obj);
            }

            if (isArray(obj)) {
                for (var i = 0; i < obj.length; i++) {
                    obj[i].id = Math.random().toString(36).substr(3);
                    this.ajaxArr.unshift(obj[i]);
                }
            }
        },

        send: function(obj) { //点击可以发送

            this.setData(obj);

            //如果定时器停了
            if (this.moveArr.length == 0) {
                this.initIsOne = false;
                this.init();
                this.moveTimer = requestAnimationFrame(this.move.bind(this));
            }

            //只要页面滚动的不是最后一个数据，就不能init
            if (this.initIsOne) {
                this.initIsOne = false;
                //init方法不能同一时间，多次执行，否则ui试图会重叠；
                //执行一次 就可以了，把链接又开起来了
                this.init();
            }
        },
        init: function() {
            var obj = this.ajaxArr.shift();

            if (obj) {

                obj.isTrue = true; //避免多次执行

                $('.app').append(`<div class="scroll-li ${obj.id}">${obj.font}${obj.id}</div>`);

                obj.left = $(`.${obj.id}`).css('transform').split('(')[1].split(')')[0].split(',')[4] - 0;

                this.moveArr.push(obj);

            }
        },
        //对moveArr数组里面的left字段 --
        move: function() {
            stats.begin();

            this.moveTimer = requestAnimationFrame(this.move.bind(this));

            if (this.moveArr.length == 0) {
                cancelAnimationFrame(this.moveTimer);
                //console.log('定时器停了');
            }

            for (var i = 0; i < this.moveArr.length; i++) {

                var obj = this.moveArr[i];

                obj.left--;

                //下一个滚动时机
                if (obj.left <= 0 && obj.isTrue) {
                    obj.isTrue = false;
                    if (this.ajaxArr.length == 0) {
                        this.initIsOne = true;
                    }
                    this.init();
                    // console.log('可以放下一个', this.moveArr);
                }

                //单条播放完
                if (obj.left <= (-winW)) {
                    $(`.${obj.id}`).remove();
                    this.moveArr.shift(i, 1);
                    // console.log('删了一个');
                }

                $(`.${obj.id}`).css({
                    '-webkit-transform': 'translate3d(' + obj.left + 'px, 0, 0)'
                });

            }
            
            stats.end();
        }
    };

    window.scroll = scroll;
})();
````

## 使用
### 初始化和发送
````javascript
    //多条数据
    var arr = [{ font:'滚动数据' }];
    scroll.send(arr);

    //单条数据
    var obj = {font:'单条滚动数据'}
    scroll.send(obj);
````
### 总结
* 没对实现过程进行封装，在使用时需要在init方法，修改插入dom结构
* 部分地方用的zepto方法，在后面会改成用原生js吧
* demo大体上按照自己的想法实现了，效果勉强还行
* 还有优化的工作要做，例如：
    - 总结需求，封装js插件
    - 对模块化的支持
    - 滚动是对dom直接添加与删除，能否复用dom结构；避开对dom频繁操作
    
[demo效果](https://zhongs.github.io/scroll/single_scroll/index.html)

[源码地址](https://github.com/zhongs/scroll/tree/master/single_scroll)
